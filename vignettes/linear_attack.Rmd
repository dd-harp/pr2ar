---
title: "Linear Attack Rate"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Linear_attack_rate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r load_libraries, include = FALSE}
library(deSolve)
library(ggraph)
library(ggplot2)
library(igraph)
```

# Overview

We want to estimate the probability that a person is infected by a mosquito
bite during a time period of about fourteen days. We know that the recovery
rate is slow because it takes around 200 days. What is a good way to take
data about the prevalence of infection and estimate the attack rate?

Austin has a document that works through a method for this. It starts with
a simple algorithm for a time step and then modifies it. The modified algorithm
has a nice name, "peek ahead," and it has a clear explanation, that it
allows a transition from $I\rightarrow S\rightarrow I$. I'm uncomfortable
with its derivation.

This document is here to make me more comfortable with the derivation.
I'll either see that it's numerically very close to the master equation,
or I'll derive a time step that is similarly linear in the attack rate.


# An S--I--T Model for Attack Rate

## The Model
We use a model that includes treatment because it forces us to be more
honest about using matrices. It's so easy to drop the susceptible state
and work with real numbers.
There is a rate of treatment, $\tau$, and
a rate for leaving the treated state, back to susceptible, $u$.

As a graph, we see three states and four transitions.
```{r model_graph}
model_graph <- graph_from_literal(
    S -+ infect -+ I, I -+ recover -+ S, I -+ treat -+ T, T -+ wane -+ S
)
plot(model_graph)
```


## The master equation

The two compartments are susceptible and infected. The recovery rate
is $r=1/200$ per day. The infection rate is $h$. If we write this as
a master equation, it's a set of differential equations.
$$
  \frac{dx}{dt} = \left[\begin{array}{ccc}
  -h & r & u\\
  h & -r-\tau & 0 \\
  0 & \tau & -u
  \end{array}\right]x
$$
The master equation, as written, is a matrix differential equation. Its solution will
be a matrix exponential. Both of these terms are on Wikipedia, for reference.

Let's look at the master equation, so that we can compare it later.
First try integrating the equation as it stands.
```{r master_equation_integration}
A_matrix <- function(h, sit_params) with(
  sit_params,
  matrix(
    c(-h, r, u,
      h, -r - tau, 0,
      0, tau, -u),
    nrow = 3,
    byrow = TRUE
    )
  )

cme_trajectory <- function(I, C, h, sit_params) {
    params <- A_matrix(h, sit_params)
    state <- c(S = 1 - I - C, I = I, T = C)
    cme <- function(t, state, parameters) {
        list(as.numeric(parameters %*% state))
    }
    times <- seq(0, 14, by = 0.1)
    deSolve::ode(y = state, times = times, func = cme, parms = params)
}

cme_week <- function(I, C, h, sit_params) {
    trajectory <- cme_trajectory(I, C, h, sit_params)
    unlist(trajectory[nrow(trajectory), c("S", "I", "T")])
}

plot_master_equation <- function(I, C, h, sit_params) {
    trajectory <- cme_trajectory(I, C, h, sit_params)
    tdf <- rbind(
        data.frame(time = trajectory[, 1], value = trajectory[, 2], component = "S"),
        data.frame(time = trajectory[, 1], value = trajectory[, 3], component = "I"),
        data.frame(time = trajectory[, 1], value = trajectory[, 4], component = "T")
    )
    ggplot(tdf, aes(x = time, y = value, color = component)) + geom_line() + ylim(0, 1)
}
plot_sit_params <- list(r = 1/200, tau = 1/90, u = 1/20)
plot_master_equation(0.6, 0.1, 1/20, plot_sit_params)
```

We could try to write the solution to the master equation as $\exp(At)x_0$, but this
matrix is singular, so we'd need some more complicated methods. The matrix is singular
because the system can be stated without using $S$. You could replace $S=1-I-T$, so
it's rank deficient.
```{r an_a_matrix}
A <- A_matrix(1/20, sit_params)
eigen(A)
```
When we see, for an SIR system, that $S$ is redundant, we rewrite it in terms of
$I$ and $R$. Can we formalize that process so that we can do a similar rewrite
for larger matrices? The rewrite will also pull out the attack rate.
Let's work through it for the SIT system here.

We are going to assume that $S = 1-I-T$. Start by dropping the first
equation because it's redundant. We still have the full state space though.
$$
  \left[\begin{array}{ccc}
  h & -r-\tau & 0 \\
  0 & \tau & -u
  \end{array}\right]
  \left[\begin{array}{c}1-I-T \\ I \\ T\end{array}\right]
$$
This is equivalent to
$$
\left(
\left[\begin{array}{cc}
  -r-\tau & 0 \\
  \tau & -u
  \end{array}\right] - \left[\begin{array}{cc}
  h & h  \\
  0 & 0
  \end{array}\right]
  \right)
  \left[\begin{array}{c}I \\ T\end{array}\right] +
  \left[\begin{array}{c}h \\ 0\end{array}\right]
$$
There is a definite structure to the attack rate in this generator matrix. We
can think of it as $(M-[b\:b])x + b$.

## Simple Forward Equation 

We can create an algorithm to take a discrete time step by approximating
the master equation.
\begin{eqnarray}
  \frac{dx}{dt} & = & A x_0 \\
  x - x_0 & \approx & \Delta t A x_0 \\
  x & \approx & (1 + \Delta t A) x_0
\end{eqnarray}
If we fill in the values from above, and we rescale all the rates
by $h =h\Delta t$, $\tau=\tau\Delta t$, $r=r\Delta t$,
$$
x =
\left[\begin{array}{ccc}
  1-h & r & u\\
  h & 1-r-\tau & 0 \\
  0 & \tau & 1-u
  \end{array}\right]x_0
$$
We can also reduce this by eliminating the $S$ state. Take $x=(I,T)$.
$$
x =
\left[\begin{array}{cc}
  1-r-\tau-h & 0 \\
  \tau & 1-u-h
  \end{array}\right]x_0 + \left[\begin{array}{c}h \\ 0\end{array}\right]
$$
This should match the "Bad example" from Austin's work if we set $\tau=0$, so
$$
  I = (1-r-h)I_0 + h = h(1-I)+(1-r)I_0
$$
We complete the equivalence by replacing $A=1-e^{-h}\approx h$ and $Q=e^{-r}\approx 1-r$ to get
$$
I=A(1-I_0) + QI_0
$$
Dave spotted a problem with this formulation. If you look at its equilibrium value,
$I=A/(1+A-Q)$. For the largest attack rate and $r=1/200$, a two-week time step gives $I=0.93$.

Physically, the error is a result of our approximation. Using a linear approximation
is equivalent to permitting one transition in the system. That means
we permit $S\rightarrow I$, or $I\rightarrow S$, but we miss the case where somebody
recovers during the duration and then gets infected. We would catch that if we used the complete
solution.

The "better start" is of the form $I=A(1-QI_0) + QI_0$. If you take this to a small-time
limit for $A\approx h$ and $Q\approx 1-r$, and identify $I'=(I-I_0)/\Delta t$,
$$
I'=A(1-QI) + (Q-1)I = A + (Q-AQ-1)I=A(1-I) + (Q-1)(1-A)I
$$
$$
I'=hS + (-r)(1-h)I = hS-rI
$$
The small-time behavior is correct. How about numerically?

There's one small change that might be interesting. We could restate the discrete
time step using an implicit formulation. It suffers the same problem of having a maximum
equilibrium $I$, but it would be more stable for time steps.
\begin{eqnarray}
  \frac{dx}{dt} & = & A x_0 \\
  x - x_0 & \approx & \Delta t A x \\
 (1 - \Delta t A) x & \approx & x_0
\end{eqnarray}


## Our operational constraint

We need to approximate one time step of the system in such a way that we can
solve it for the attack rate. The simplest form of this is to come up with
a time step that can be split into a part with the attack rate and a part without.
$$
  x = (M_0 + hM_1) x_0
$$
Then we can solve for the attack rate, given a fair knowledge of the other constants and
the two prevalence values.

How do we find this new equation? We have an intuition that we need to include, at least,
the $I\rightarrow S \rightarrow I$ transition, and we want to linearize around some value
of the attack rate.


## Discrete time approach

One approach is to say that a ten-day duration is ten one-day steps, so that it's possible
to recover and get sick again on different days.
Let's work with the reduced system, where we've removed the susceptible state.
Here, the time step would be
$$
  x_1 = (1 + M-B)x_0 + b
$$
where we assume $B, M, b$ are rescaled by the time step. If we iterate this
to get $x_1$, then $x_2$, then $x_3$, the result is
$$
x_3 = b + (1+M-B)b + (1+M-B)^2b + (1+M-B)^3x_0
$$
As a series, it's
$$
x_n = \sum_{i=0}^{i=n-1}(1+M-B)^ib + (1+M-B)^nx_0
$$

While a single time step was linear in attack rate, two or more time steps
aren't linear in the attack rate.
We can reduce express the series as a fraction if we think that's handy.
$$
x_n = \frac{1-(1+M-B)^n}{1-(1+M-B)}b + (1+M-B)^nx_0
$$
It's probably more useful to write that sum with Horner's method. Start with
$\mbox{Horner}(0)=1$, and recursively define
$$
\sum_{i=0}^{i=n-1}(1+M-B)^i = \mbox{Horner}(n) = \mbox{Horner}(n-1) (1+M-B) + 1
$$

I'll bet we could pick a value for the matrix $B=[b,b]$, then solve for the vector $b$ and iterate to get
a solution. We would shift the equation to have a left-hand side (LHS) and right-hand side (RHS)
like this.
$$
x_n- (1+M-B)^nx_0 = \frac{1-(1+M-B)^n}{1-(1+M-B)}b
$$
Then the (1,1) component of the matrix would give us a value for $h$.
$$
x_n- (1+M-B)^nx_0 = \frac{1-(1+M-B)^n}{1-(1+M-B)}\left[\begin{array}{c}h \\ 0\end{array}\right]
$$


Let's define a problem. Use the master equation to determine a change over a week
from an initial $x_0$ to a final $x_1$. Then use our technique to guess $h$.
```{r define_problem}
actual_h <- 1 / 20
known_params <- list(r = 1 / 200, tau = 1 / 120, u = 1 / 20)
x0 <- c(0.3, 0.6, 0.1)
x1 <- cme_week(x0[2], x0[3], actual_h, known_params)
rbind(x0, x1)
```

```{r construct_and_test}
# the matrix 1 - M - B
one_m_b <- function(h, dt_params) with(dt_params, {
  matrix(
    c(1 - r - tau - h, 0,
      tau, 1 - u - h),
    nrow = 2,
    byrow = TRUE
    )
})

# The coefficient of b on the right-hand side.
coeff_of_b <- function(mb, step_cnt) {
  one <- diag(1, dim(mb)[1], dim(mb)[2])
  total <- one
  # The 14 is one week.
  for (i in 2:step_cnt) {
    total <- total %*% mb + one
  }
  total
}

coeff_of_b_slow <- function(mb, step_cnt) {
  total <- diag(1, dim(mb)[1], dim(mb)[2])
  for (i in 1:(step_cnt - 1)) {
    total <- total + matpow::matpow(mb, i)$prod1
  }
  total
}

test_coeff <- function() {
  known_params <- list(r = 1 / 200, tau = 1 / 120, u = 1 / 20)
  mb <- one_m_b(1/20, known_params)
  cba <- coeff_of_b(mb, 5)
  cbb <- coeff_of_b_slow(mb, 5)
  all(abs(as.array(cba) - as.array(cbb)) < 1e-7)
}
stopifnot(test_coeff())

test_whole_equation_forward <- function() {
  actual_h <- 1 / 20
  known_params <- list(r = 1 / 200, tau = 1 / 120, u = 1 / 20)
  x0 <- matrix(c(0.6, 0.1), ncol = 1)
  x1 <- matrix(cme_week(x0[1], x0[2], actual_h, known_params)[2:3], ncol = 1)

  step_cnt <- 100
  dt <- 14 / step_cnt
  dt_params <- as.list(unlist(known_params) * dt)
  mb <- one_m_b(actual_h, dt_params)
  cob <- coeff_of_b(mb, step_cnt)
  b <- matrix(c(actual_h * dt, 0), ncol = 1)
  x1p <- cob %*% b + matpow::matpow(mb, step_cnt)$prod1 %*% x0
  list(x1, x1p)
}
test_whole_equation_forward()
```

```{r iterate_to_solution}
iterative_attack_rate <- function(x0, x1, h_initial, sit_params, dt_days, eps = 0.01, maxiter = 50) {
  x0_column <- matrix(x0[(length(x0) - 1):length(x0)], ncol = 1)
  x1_column <- matrix(x1[(length(x1) - 1):length(x1)], ncol = 1)
  step_cnt <- round(14 / dt_days)
  dt_days <- 14 / step_cnt  # In case dt doesn't divide evenly.
  dt_params <- as.list(unlist(sit_params) * dt_days)
  h_guess <- h_initial * dt_days
  for (iterative_refinement in 1:maxiter) {
    mb <- one_m_b(h_guess, dt_params)
    
    lhs <- x1_column - matpow::matpow(mb, step_cnt)$prod1 %*% x0_column
    rhs <- coeff_of_b(mb, step_cnt)
    # cat(paste("lhs", str(lhs), "\n"))
    # cat(paste("rhs", str(rhs), "\n"))
    h_next <- lhs[1, 1] / rhs[1, 1]
    cat(paste("h", h_guess, h_next, "\n"))
    if (abs(h_next - h_guess) < eps * h_guess) break
    h_guess <- h_next
  }
  list(ans = h_guess / dt_days, iterations = iterative_refinement)
}

relative_error <- function(x, y) {abs((x - y) / y)}

res <- iterative_attack_rate(x0, x1, actual_h, known_params, 0.01, eps = 0.001)
data.frame(
  ar_days = 1/res$ans,
  relerr = relative_error(res$ans, actual_h),
  iterations = res$iterations)
```
An error of 30% is too high. There's a mistake somewhere.

Out of curiosity, if we used the steady-state peekahead version, what
is the equilibrium value for these prevalences?


## A continuous deterministic approach

We know that the master equation has a solution of the form
$x = \exp(At) x_0$. We could start there in order to linearize around
some attack rate. We use the structure of the operator $A$ and break out
the attack rate, itself.

We determined above that our matrix differential equation for the master equation
is
$$
\frac{dx}{dt} = \left([b~b] + M\right)x + b.
$$
I've been naming that matrix $B=[b~b]$. A matrix of this form has a steady
state $\hat{x}=-A^{-1}b$. You can rewrite it as
$$
\frac{dx}{dt} = \left(B + M\right)(x - \hat{x}).
$$
The equation for the perturbation is then
$$
\frac{d\tilde{x}}{dt} = \left(B + M\right)\tilde{x}.
$$
As a word of caution, we may not be able to rewrite the equation this way because
we don't yet know the value for the attack rate. In that case, we would treat the $b$
term as a separate condition for the integral. 
Meanwhile, if we write the solution to the equation above as an exponential,
$$
x = e^{(B + M)t}x_0
$$
We can't separate the exponential into two because $B$ and $M$ don't commute.
We could take a Taylor series in $b$ around some given value. That might be an improvement
over assuming it's linear around $b=0$.
$$
  x \approx \left(e^{(B_0 + M)t} + e^{(B_0 + M)t}\tilde{B}\right)x_0
$$

## A continuous stochastic approach

This approach treats the system as a continuous-time stochastic
system and asks the probability for all paths. It has the advantage
that we can specify, exactly, that we permit $I\rightarrow S\rightarrow I$
but no other multi-step jumps.
It has the disadvantage that its matrix form is a product integral and
it's non-matrix form will have convolutions.

